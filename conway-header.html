<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
<style>
    #conway-canvas-container {
        flex: 1 1 auto;
        min-width: 0;
        height: 56px;
        overflow: hidden;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 1rem;
        order: 2;
    }

    /* Ensure brand stays first in flex order */
    .navbar-brand-container {
        order: 1 !important;
        margin: 0 !important;
        flex-shrink: 0 !important;
    }

    /* Hide empty search container */
    #quarto-search:empty {
        display: none !important;
    }

    /* Nav collapse comes after animation */
    #navbarCollapse {
        order: 3 !important;
        flex-shrink: 0 !important;
    }


    /* Theme toggle stays at the end */
    .quarto-navbar-tools {
        order: 4 !important;
        flex-shrink: 0 !important;
    }

    #conway-canvas-container canvas {
        display: block;
        touch-action: none;
        width: 100% !important;
        height: 100% !important;
        -webkit-mask-image:
            linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
        mask-image:
            linear-gradient(to right, transparent 0%, black 5%, black 95%, transparent 100%);
    }

    /* Hide on mobile (Bootstrap lg breakpoint) */
    @media (max-width: 991.98px) {
        #conway-canvas-container {
            display: none !important;
        }
    }
</style>

<div id="conway-canvas-container"></div>

<script>
    let cols, rows;
    const cellSize = 2;
    let grid, nextGrid, fadeGrid;
    let canvasWidth, canvasHeight;
    let isPaused = false;
    let myCanvas;
    let p5Instance;

    // Theme colors
    let bgColor;
    let cellColor;

    function getThemeColors() {
        const navbar = document.querySelector('#quarto-header .navbar');
        const container = document.getElementById('conway-canvas-container');

        if (navbar) {
            const navbarBg = window.getComputedStyle(navbar).backgroundColor;
            const rgbMatch = navbarBg.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
            if (rgbMatch) {
                bgColor = color(parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3]));
                if (container) {
                    container.style.backgroundColor = navbarBg;
                }
            }
        } else {
            bgColor = color(33, 37, 41);
        }

        const isDark = document.body.classList.contains('quarto-dark');
        if (isDark) {
            cellColor = color(42, 161, 152); // teal #2aa198
        } else {
            cellColor = color(24, 188, 156); // teal #18bc9c
        }
    }

    // Don't auto-run setup - we'll call it manually after DOM is ready
    p5.disableFriendlyErrors = true;

    function initCanvas() {
        let container = document.getElementById('conway-canvas-container');
        canvasWidth = container.offsetWidth;
        canvasHeight = container.offsetHeight;

        // Skip if container has no size yet
        if (canvasWidth === 0 || canvasHeight === 0) return;

        myCanvas = createCanvas(canvasWidth, canvasHeight);
        myCanvas.parent('conway-canvas-container');
        frameRate(12);

        getThemeColors();
        initializeGrids();
        randomizeGrid();

        // Click to toggle pause
        myCanvas.mousePressed(() => {
            isPaused = !isPaused;
            if (isPaused) {
                noLoop();
            } else {
                loop();
            }
        });
    }

    // Empty setup - we initialize manually
    function setup() {
        noLoop(); // Don't start drawing until we're ready
    }

    function windowResized() {
        let container = document.getElementById('conway-canvas-container');
        if (!container) return;

        let newWidth = container.offsetWidth;
        let newHeight = container.offsetHeight;

        if (newWidth === canvasWidth && newHeight === canvasHeight) return;
        if (newWidth === 0 || newHeight === 0) return;

        canvasWidth = newWidth;
        canvasHeight = newHeight;
        resizeCanvas(canvasWidth, canvasHeight);
        initializeGrids();
        randomizeGrid();
    }

    function initializeGrids() {
        cols = floor(width / cellSize);
        rows = floor(height / cellSize);

        grid = Array(cols).fill(null).map(() => Array(rows).fill(0));
        nextGrid = Array(cols).fill(null).map(() => Array(rows).fill(0));
        fadeGrid = Array(cols).fill(null).map(() => Array(rows).fill(0));
    }

    function randomizeGrid() {
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                grid[i][j] = random() < 0.25 ? 1 : 0;
                fadeGrid[i][j] = grid[i][j];
            }
        }
    }

    function countNeighbors(x, y) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                let col = (x + i + cols) % cols;
                let row = (y + j + rows) % rows;
                count += grid[col][row];
            }
        }
        return count;
    }

    function updateGrid() {
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                let neighbors = countNeighbors(i, j);
                let state = grid[i][j];

                if (state === 0 && neighbors === 3) {
                    nextGrid[i][j] = 1;
                } else if (state === 1 && (neighbors < 2 || neighbors > 3)) {
                    nextGrid[i][j] = 0;
                } else {
                    nextGrid[i][j] = state;
                }
            }
        }

        let temp = grid;
        grid = nextGrid;
        nextGrid = temp;

        // Add some random cells to keep it alive
        let aliveCount = 0;
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                if (grid[i][j] === 1) aliveCount++;
            }
        }

        if (aliveCount < cols * rows * 0.05) {
            for (let k = 0; k < 20; k++) {
                let x = floor(random(cols));
                let y = floor(random(rows));
                grid[x][y] = 1;
                fadeGrid[x][y] = 1.0;
            }
        }
    }

    function updateFadeGrid() {
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                if (grid[i][j] === 1) {
                    fadeGrid[i][j] = 1.0;
                } else {
                    fadeGrid[i][j] *= 0.7;
                    if (fadeGrid[i][j] < 0.01) {
                        fadeGrid[i][j] = 0;
                    }
                }
            }
        }
    }

    function draw() {
        background(bgColor);

        noStroke();
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                if (fadeGrid[i][j] > 0) {
                    let alpha = fadeGrid[i][j] * 255;
                    fill(red(cellColor), green(cellColor), blue(cellColor), alpha);
                    rect(i * cellSize, j * cellSize, cellSize, cellSize);
                }
            }
        }

        updateGrid();
        updateFadeGrid();
    }

    // Watch for theme changes
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.attributeName === 'class') {
                getThemeColors();
            }
        });
    });

    if (document.body) {
        observer.observe(document.body, { attributes: true });
    }

    // Move container into navbar after DOM loads
    document.addEventListener('DOMContentLoaded', () => {
        const navbarContainer = document.querySelector('.navbar-container');
        const brandContainer = document.querySelector('.navbar-brand-container');
        const quartoSearch = document.querySelector('#quarto-search');
        const container = document.getElementById('conway-canvas-container');

        if (navbarContainer && brandContainer && container) {
            // Remove mx-auto from brand so it stays left
            brandContainer.classList.remove('mx-auto');

            // Insert into navbar (before search element if it exists)
            if (quartoSearch) {
                navbarContainer.insertBefore(container, quartoSearch);
            } else {
                brandContainer.after(container);
            }

            // Now initialize the canvas after it's in the right place
            // Delay to let flexbox layout settle before measuring width
            setTimeout(() => {
                initCanvas();
                loop(); // Start the animation
            }, 100);
        }
    });
</script>
